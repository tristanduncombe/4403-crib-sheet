\subsubsection{Stack Organisation}
\subsubsubsection{Definition}
A stack machine consists of the following chunks of memory.
\begin{itemize}
    \item \textbf{stack} - the portion of memory used for both calculating the values of 
    expressions as well as storing activation records for every active procedure call.
    \item \textbf{heap} - the portion of memory for dynamic allocation of Objects.
    \item \textbf{code space} - the portion of memory where the machine instructions are 
    stored.
\end{itemize}
The stack and heap are stored in one contiguous area of memory. The stack grows from the 
bottom (address 0) and the heap grows down from the top.

The machine has four special registers:
\begin{itemize}
    \item \textbf{stack pointer} - contains the address for the top of the stack + 1
    \item \textbf{stack limit} - contains the address of the upper limit for the stack 
    and the bottom of the heap
    \item \textbf{frame pointer} - contains the address of teh stack frame for the 
    current procedure
    \item \textbf{program counter} - contains the address of the next machine instruction
\end{itemize}

\subsubsubsection{Procedures}
Each time a procedure is entered via a call, the machine must keep track of information 
such as the return address and the local variables for that call in a procedure frame. 
This frame is stored on the stack.

A pointer to the current procedures' frame is stored in a globally known location.
\subsubsubsubsection{Calling a Procedure}
\begin{itemize}
    \item parameters to the procedure are pushed to the stack
    \item a static link is pushed onto the stack
    \item the current frame pointer is pushed onto the stack to create the dynamic link
    \item the frame pointer is set so that it contains the address of the start of the 
    new stack frame
    \item the current value of the program counter is pushed onto the stack to form the 
    return address
    \item the program counter is set to the address of the procedure
    \item space is allocated on the stack for any local variables
\end{itemize}
\begin{center}
    \image[\columnwidth/2]{Stack Frame.png}
\end{center}

\subsubsubsubsection{Returning From a Procedure}
\begin{itemize}
    \item the program counter is set to the return address in the current activation record
    \item the frame pointer is set to the dynamic link
    \item the stack pointer is set so that all the space used by the stack frame (but not 
    parameters) is popped from the stack
    \item execution continues at the instruction addressed by the (restored) program counter
    \item after return, the calling procedure handles deallocating any parameters
\end{itemize}

\subsubsubsubsection{Local Variables}
Local variables are stored within the procedures frame. They are accessed by an offset 
relative to the frame pointer.

\subsubsubsubsection{Non-local Variables}
To allow access to variables outside of the enclosing procedure, the stack frame for a 
procedure includes a \textit{static link} which contains the address of the stack frame 
for the enclosing procedure (the procedure in which the enclosed procedure is defined).

To access the non-local variable $n$ from a procedure, we continuesly access the static link 
of the enclosing procedures until we are in the procedure in which $n$ is defined. We can then
add the offset to the variable $n$ to get the final address of the non-local variable.