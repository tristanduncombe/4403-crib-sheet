\subsection{Collection Types}

\setlength{\tabcolsep}{0pt} 

\subsubsection{Arrays}
Arrays are a mutable collection of elements stored on the heap.

For an array, \verb!a!, to be modified by a method, it must include
\verb!modifies a! in the specification.

\begin{tabular}{r@{\hspace{0.1cm}}l@{}}
        Type & \verb!array<T>!\\
        Creation & \verb!var a := new T[length];!\\
        Accessing & \verb!var value := a[i];!\\
        Assigning & \verb!a[i] := value;!\\
        Alias & \verb!var b := a;!\\
        Length & \verb!var l := a.Length;!\\
        Slicing & \verb!var s: seq<T> := a[start...end];!
\end{tabular}
\subsubsubsection{Multi-dimensional Arrays}
\begin{tabular}{r@{\hspace{0.1cm}}l@{}}
        Type & \verb!array<array<...<array<T>>>>!\\
        Creation & \verb!var a := new T[l1, l2, ..., lN];!\\
        Accessing & \verb!var value := a[i1, i2, ..., iN];!\\
        Asigning & \verb!a[i1, i2, ..., iN] := value;!\\
        Alias & \verb!var b := a;!\\
        Length & \verb!(l1, l2, ..., lN) := (a.Length1,! \\
                & \verb!        a.Length2, ... a.LengthN);!
\end{tabular}

\subsubsection{Sequences}
Sequences are used to represent an ordered list. They are immutable.
\begin{tabular}{r@{\hspace{0.1cm}}l@{}}
        Type & \verb!seq<T>!\\
        Creation & \verb!var s := [x1, x2, ..., xN];!\\
        Accessing & \verb!var value := s[i];!\\
        Length & \verb!var l := |s|;!\\
        Slicing & \verb!var t := a[start...end];!\\
        Appending & \verb!var u := s + t;!\\
        Contains & \verb!value in s;!\\
        Excludes & \verb|value !in s;|
\end{tabular}

\subsubsection{Sets}
Sets are used to represent an orderless collection of elements, without repetition. Sets are immutable.
\begin{tabular}{r@{\hspace{0.1cm}}l@{}}
        Type & \verb!set<T>!\\
        Creation & \verb!var s := {x1, x2, ..., xN};!\\
        Equality & \verb!{x1, x2} == {x2, x1} ==!\\
                & \verb!        {x1, x1, x2, x2};!\\
        Subset & \verb!s <= t!\\
        Proper Subset & \verb!s < t!\\
        Union & \verb!var u := s + t;!\\
        Intersection & \verb!var u := s * t;!\\
        Difference & \verb!var u := s - t;!\\
        Contains & \verb!elem in s;!\\
        Excludes & \verb|elem !in s;|
\end{tabular}

\subsubsection{Multisets}
Multisets are used to represent an orderless collection of elements, with repetition. Multisets are immutable.
\begin{tabular}{r@{\hspace{0.1cm}}l@{}}
        Type & \verb!multiset<T>!\\
        Creation & \verb!var s := multiset{x1, ..., xN};!\\
        From seq & \verb!var s := multiset([x1, ..., xN]);!\\
        From set & \verb!var s := multiset({x1, ..., xN});!\\
        Equality & \verb!multiset{x1, x2} == !\\
                & \verb|        multiset{x2, x1} !=|\\
                & \verb!        multiset{x1, x1, x2, x2};!\\
        Union & \verb!var u := s + t;!\\
        Difference & \verb!var u := s - t;!\\
        Contains & \verb!elem in s;!\\
        Excludes & \verb|elem !in s;|\\
        Disjoint & \verb|elem !! s;|
\end{tabular}

\subsection{Specification Keywords}
\subsubsection{Requires}
A requires clause stipulates a condition \verb!P! which must be true upon entry to the method.
\subsubsection{Ensures}
A requires clause stipulates a condition \verb!R! which must be true when exiting the method.
\subsubsection{Modifies}
A modifies clause is required if a method changes a value on the heap (i.e. a value in an array is changed).
\subsubsection{Reads}
A reads clause is required if a method reads a value on the heap (i.e. a value in an array is read).
\subsubsection{Invariant}
An invariant clause stipulates a condition \verb!I! which must be true at the beginning and end of a loop.
\subsubsection{Decreases}
A decreases clause indicates a value \verb!D! which decreases after every iteration of a loop.
\subsubsection{Forall}
A forall clause is used to stipulate that a condition \verb!Q! must hold forall values of a given variable.
For example, \verb!forall i :: P[i] ==> Q[i]! requires \verb!Q[i]! to hold for all values of \verb!i! where \verb!P[i]! holds.
\subsubsection{Exists}
An exists clause is used to stipulate that a condition \verb!Q! must hold for at least one value of a given variable.
For example, \verb!exists i :: P[i] ==> Q[i]! requires \verb!Q[i]! to hold for at least one value of \verb!i! where \verb!P[i]! holds.
\subsubsection{Fresh}
Fresh is used to indicate that a value stored on the heap must be brand new with no modifications.
For example, \verb!fresh(x)! requires x to be a brand new value on the heap.
\subsubsection{Old}
Old is used to reference the value on the heap before the method began. 
For example, \verb!old(a[i])! refers to the element at index \verb!i! at the beginning of the method.
